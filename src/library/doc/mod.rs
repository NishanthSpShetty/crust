#![allow(dead_code)]

#[allow(non_camel_case_types)]
#[derive(Clone, Copy)]
pub enum DocType {
    NO_STRICT,
    STRICT,
    STRUCT_INIT,
    NO_RETURN,
    INCLUDE_STMT,
    NO_POINTER,
    CONSTRUCTOR,
    CRUST,
    DEFAULT,
    UNION,
    UNION_DECL,
    OPERATOR_OVERLOAD,
}

impl DocType {
    pub fn get_doc(self) -> &'static str {
        match self {
            DocType::STRICT => {
                "\n/*Crust with Strict Mode enabled, declares all variables as immutable.\n * If \
                 you are mutating the below variable anywhere in program, please change the \
                 declaration statement as\n * let mut var_name:type=init_val;\n **/\n"
            }
            DocType::NO_STRICT => "\n/*Avoid using mutable variables unless it is necessary to do so\n */\n",
            DocType::STRUCT_INIT => {
                "\n/** Declaration of a structure should be completed with initialization of it's \
                 fields\n * It should be in the following format\n * let variable:struct_name = struct_name { \
                 member1:value1, member2:value2,..}\n */"
            }
            DocType::NO_RETURN => {
                "\n/** Crust tries to identify return statement and replace with rust equivalent\n \
                 * shorthand notation. If error found in this line, Please replace shorthand \
                 notation \n * with return statement \n **/\n"
            }
            DocType::INCLUDE_STMT => {
                "\n/** Crust doesn't resolve C/C++ dependencies or included header.\n* You may have \
                 to define your own module and implement those functionality in Rust \n* Or you \
                 can translate header file with Crust to produce Rust code. * \n* >>>>>>>>"
            }
            DocType::NO_POINTER => {
                "\n/** Crust doesn't support pointers yet,\
                \n * Please handle the pointers manually with rust refernce, Rc, Arc or RefCell \
                \n * ======> "
            }
            DocType::CONSTRUCTOR => {
                "\n/** Rust structures do not support constructors\
                \n * Please handle them with static builder functions\n * >>>>>>>>"
            }
            DocType::CRUST => {
                "/*************************************************************************\
                \n * This file was generated by CRUST by an automated semantics preserving\
                \n * translation from C/C++ to Rust\
                \n * CRUST isn't perfect and may require manual editing\
                \n * Check warnings and errors and refer to the official Rust Documentation\
                \n ************************************************************************/\n"
            }
            DocType::UNION => {
                "\n/* CRUST does not hanlde C/C++ tagged union type completely.\
				 \n *It translates union type into Rust Some type. \
				 \n *Please check the varient used properly */\n"
            }
            DocType::UNION_DECL => {
                "\n/* Union declaration must be translated to Rust equivalent Some type varients\
				\n * Make changes before compilation \n */"
            }
            DocType::OPERATOR_OVERLOAD => {
                "\n/* Operator overloading is not supported at the current state of Crust.\
				\n * It will convert into operator_op_name\
				\n * Ex : operator==()  will be defined as operator_eq()\n */"
            }
            _ => "//Doc Not Found. Please Report bug",
        }
    }
}
